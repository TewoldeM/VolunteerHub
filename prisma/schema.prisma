generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                     @id @default(uuid())
  name                  String                     @db.Text
  token                 String?
  email                 String                     @unique
  password              String
  createdAt             DateTime                   @default(now())
  failedLoginAttempts   Int                        @default(0)
  isLocked              Boolean                    @default(false)
  lockUntil             DateTime?
  IsBlocked            Boolean        @default(false) // Permanent block (admin action)
  ResetToken           String? // For Email verification
  ResetTokenExpires    DateTime? // Expiration time for Email verification token
  roles                 Role[]                     @default([VOLUNTEER])
  applications          Application[]
  organizations         Organization[]             @relation("OrganizationOwner")
  orgApplications       OrganizationApplication[]  @relation("OrgApplicant")
  verifiedDocs          VerificationDocument[]     @relation("VerifiedBy")
  reviewedApplications  OrganizationApplication[]  @relation("ReviewedBy")
  PasswordResetToken   String? // For forgot password functionality
  PasswordResetExpires DateTime? // Expiration time for password reset token
  @@index([email])
}

model Organization {
  id                   String                      @id @default(uuid())
  name                 String                      @unique @db.Text
  address              String?
  city                 String?                     @db.Text
  province             String?                     @db.Text
  postalcode           String
  country              String
  phone                String?
  website              String?
  linkedinURL          String?
  facebookURL          String?
  twitterURL           String?
  photo                String?
  mission              String?
  description          String?                     @db.Text
  createdAt            DateTime                    @default(now())
  updatedAt            DateTime                    @updatedAt
  owner                User                        @relation("OrganizationOwner", fields: [ownerId], references: [id])
  ownerId              String
  opportunities        Opportunity[]
  events               Event[]
  orgtype              OrganizationType
  categories           OrganizationCategory[]
  verificationStatus   VerificationStatus          @default(PENDING)
  verificationDocs     VerificationDocument[]
  orgApplication       OrganizationApplication?    @relation("OrgApplication")

  @@index([ownerId])
}

model OrganizationApplication {
  id             Int                           @id @default(autoincrement())
  applicant      User                          @relation("OrgApplicant", fields: [applicantId], references: [id])
  applicantId    String
  organization   Organization                  @relation("OrgApplication", fields: [organizationId], references: [id])
  organizationId String                        @unique
  status         ApplicationStatus             @default(PENDING)
  appliedAt      DateTime                      @default(now())
  reviewedAt     DateTime?
  reviewedBy     User?                         @relation("ReviewedBy", fields: [reviewedById], references: [id])
  reviewedById   String?
  documents      VerificationDocument[]

  @@index([applicantId, organizationId])
}

model VerificationDocument {
  id                Int                        @id @default(autoincrement())
  organization      Organization               @relation(fields: [organizationId], references: [id])
  organizationId    String
  orgApplication    OrganizationApplication?   @relation(fields: [orgApplicationId], references: [id])
  orgApplicationId  Int?
  documentType      DocumentType
  documentPath      String                     // Path to locally stored document
  uploadedAt        DateTime                   @default(now())
  verifiedAt        DateTime?
  verifiedBy        User?                      @relation("VerifiedBy", fields: [verifiedById], references: [id])
  verifiedById      String?

  @@index([organizationId])
}

model OrganizationCategory {
  id             Int           @id @default(autoincrement())
  organization   Organization  @relation(fields: [organizationId], references: [id])
  organizationId String
  category       Category

  @@index([organizationId])
}

model Opportunity {
  id              String         @id @default(uuid())
  about           About          @relation(fields: [aboutId], references: [id])
  aboutId         String
  datetime        Datetime       @relation(fields: [datetimeId], references: [id])
  datetimeId      String
  details         Details        @relation(fields: [detailsId], references: [id])
  detailsId       String
  filters         Filters        @relation(fields: [filtersId], references: [id])
  filtersId       String
  communication   Communication  @relation(fields: [communicationId], references: [id])
  communicationId String
  Organization    Organization?  @relation(fields: [organizationId], references: [id])
  organizationId  String?
  Application     Application[]

  @@index([organizationId])
}

model About {
  id            String       @id @default(uuid())
  title         String
  description   String
  location      Location     @relation(fields: [locationId], references: [id])
  locationId    String
  opportunities Opportunity[]
}

model Location {
  id         String     @id @default(uuid())
  country    String
  city       String
  address    String
  state      String
  zipcode    String
  about      About[]
  events     Event[]
}

model Datetime {
  id               String        @id @default(uuid())
  hasSpecificDates Boolean
  startDate        DateTime?
  endDate          DateTime?
  startTime        DateTime?
  endTime          DateTime?
  hasShifts        Boolean
  opportunities    Opportunity[]
}

model Details {
  id              String        @id @default(uuid())
  skillsRequired  String[]      @default([])
  commitmentHours Int?
  isVirtual       Boolean       @default(false)
  minAge          Int?
  opportunities   Opportunity[]
}

model Filters {
  id             String       @id @default(uuid())
  categories     Category[]   @default([])
  isVirtual      Boolean?
  locationRadius Int?
  opportunities  Opportunity[]
}

model Communication {
  id              String        @id @default(cuid())
  contactEmail    String?
  contactPhone    String?
  preferredMethod String?
  opportunities   Opportunity[]
}

model Application {
  id             Int               @id @default(autoincrement())
  user           User              @relation(fields: [userId], references: [id])
  userId         String
  opportunity    Opportunity       @relation(fields: [opportunityId], references: [id])
  opportunityId  String
  appliedAt      DateTime          @default(now())
  status         ApplicationStatus @default(PENDING)

  @@index([opportunityId])
}

model Event {
  id             Int           @id @default(autoincrement())
  title          String
  description    String
  date           DateTime
  location       Location      @relation(fields: [locationId], references: [id])
  locationId     String
  organization   Organization  @relation(fields: [organizationId], references: [id])
  organizationId String

  @@index([organizationId, locationId])
}

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Role {
  VOLUNTEER
  SUPER_ADMIN
}

enum OrganizationType {
  NONPROFIT
  GOVERNMENT
  SCHOOL
  NGO
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DocumentType {
  TAX_ID
  REGISTRATION_CERTIFICATE
  NONPROFIT_STATUS
  OTHER
}

enum Category {
  EDUCATION
  HEALTH
  ENVIRONMENT
  ANIMAL_WELFARE
  ARTS
  SPORTS
  COMMUNITY
  OTHER
}

// Why You Need the OrganizationCategory Model
// The OrganizationCategory model is essential in your case because it allows you to handle the many-to-many relationship between Organization and Category. Hereâ€™s why:

// Many-to-Many Relationship: Since an organization can have multiple categories and potentially each category could belong to multiple organizations, you need a junction table (in this case, OrganizationCategory) to represent this relationship properly.

// Easily Manage Selections: Using this model makes it easier to manage the categories associated with an organization. It allows you to add or remove categories from an organization without altering the core structure of either the Organization or Category models.
// Notes:
// OrganizationCategories: This model acts as a bridge between Organization and Category, allowing you to store multiple categories for each organization while keeping the category definitions constant and preventing any additions or removals from the category list.

// User and Organization Relationship: Make sure the @relation annotations align correctly to represent the intended relationships between the models.

// Categories in Organization: Each organization can now have multiple entries in the OrganizationCategory model, which maps to the static categories defined in the Category enum.

// This design will provide you with the necessary flexibility to manage categories while keeping the category list immutable, as per your requirements.
